generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String             @id @default(cuid())
  name                  String?
  email                 String             @unique
  password              String
  username              String?            @unique
  bio                   String?
  dateOfBirth           DateTime?
  photoProfile          String?
  photoVerification     String?
  tokens                Float?             @default(0)
  isVerified            Boolean            @default(false) @map("is_verified")
  verificationCompleted Boolean            @default(false) @map("onboarding_completed")
  coordinates           UserCoordinates?
  hangoutPlaces         UserHangoutPlace[]

  vibes       VibeType[]         @map("vibes")
  joinReasons JoinReason[]       @map("join_reasons")
  interests   InterestCategory[] @map("user_interest")

  dailyQuizzes         DailyQuiz[]           @relation("UserDailyQuizzes")
  communities          UserCommunity[]
  events               UserEvent[]
  matchesAsUser1       UserMatch[]           @relation("User1Matches")
  matchesAsUser2       UserMatch[]           @relation("User2Matches")
  matchesGiven         Match[]               @relation("UserMatches")
  matchesReceived      Match[]               @relation("MatchedUserMatches")
  placeRecommendations PlaceRecommendation[]
  eventRecommendations EventRecommendation[]

  createdAt DateTime @default(now()) @map("created_at")

  @@map("users")
}

model UserCoordinates {
  id     String @id @default(cuid())
  userId String @unique @map("user_id")

  latitude  Float
  longitude Float
  city      String?
  district  String?

  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([latitude, longitude])
  @@map("user_coordinates")
}

model UserHangoutPlace {
  id     String @id @default(cuid())
  userId String @map("user_id")

  placeName String           @map("place_name")
  placeType HangoutPlaceType @map("place_type")

  latitude  Float
  longitude Float
  city      String?
  district  String?
  address   String

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([latitude, longitude])
  @@map("user_hangout_places")
}

model Place {
  id      String    @id @default(cuid())
  name    String
  address String
  icon    String?
  type    PlaceType

  latitude  Float
  longitude Float
  city      String?
  district  String?

  description String?
  image       String?

  // Google Places integration (opsional)
  googlePlaceId String? @unique @map("google_place_id")

  vibes String[]

  rating Float?

  promos Promo[]

  createdAt            DateTime              @default(now()) @map("created_at")
  events               Event[]
  placeRecommendations PlaceRecommendation[]

  @@index([latitude, longitude])
  @@index([type, city])
  @@map("places")
}

model Event {
  id          String    @id @default(cuid())
  name        String
  description String?
  date        DateTime
  icon        String?
  image       String?
  endDate     DateTime?
  placeId     String
  communityId String?
  banner      String?

  vibes     String[]
  capacity  Int?
  price     Float?   @default(0)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  place                Place                 @relation(fields: [placeId], references: [id], onDelete: Cascade)
  community            Community?            @relation(fields: [communityId], references: [id], onDelete: SetNull)
  users                UserEvent[]
  eventRecommendations EventRecommendation[]
}

model Community {
  id            String   @id @default(cuid())
  name          String
  description   String?
  icon          String?
  image         String?
  createdAt     DateTime @default(now()) @map("created_at")
  communityType String?

  users  UserCommunity[]
  events Event[]

  @@map("communities")
}

model Promo {
  id          String  @id @default(cuid())
  placeId     String  @map("place_id")
  title       String
  description String?
  image       String?

  discountCode String   @map("discount_code")
  validUntil   DateTime @map("valid_until")
  createdAt    DateTime @default(now()) @map("created_at")

  place Place @relation(fields: [placeId], references: [id], onDelete: Cascade)
}

model Interest {
  id       String           @id @default(cuid())
  name     String           @unique
  slug     String           @unique
  category InterestCategory @default(general)

  icon  String?
  order Int?

  createdAt DateTime @default(now()) @map("created_at")

  @@index([category, order])
  @@map("interests")
}

model UserCommunity {
  userId      String   @map("user_id")
  communityId String   @map("community_id")
  joinedAt    DateTime @default(now()) @map("joined_at")

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@id([userId, communityId])
  @@map("user_communities")
}

model UserEvent {
  userId  String                @map("user_id")
  eventId String                @map("event_id")
  status  EventAttendanceStatus @default(interested)

  createdAt DateTime @default(now()) @map("created_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([userId, eventId])
  @@map("user_events")
}

model UserMatch {
  user1Id    String   @map("user1_id")
  user2Id    String   @map("user2_id")
  matchScore Float    @map("match_score")
  createdAt  DateTime @default(now()) @map("created_at")

  user1 User @relation("User1Matches", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("User2Matches", fields: [user2Id], references: [id], onDelete: Cascade)

  @@id([user1Id, user2Id])
  @@map("user_matches")
}

model Match {
  id            String @id @default(cuid())
  userId        String @map("user_id")
  matchedUserId String @map("matched_user_id")

  score         Float
  quizSessionId String @map("quiz_session_id")
  distance      Float?
  breakdown     Json

  status      MatchStatus @default(pending)
  createdAt   DateTime    @default(now()) @map("created_at")
  expiresAt   DateTime    @map("expires_at")
  respondedAt DateTime?   @map("responded_at")

  user        User @relation("UserMatches", fields: [userId], references: [id], onDelete: Cascade)
  matchedUser User @relation("MatchedUserMatches", fields: [matchedUserId], references: [id], onDelete: Cascade)

  @@unique([userId, matchedUserId, quizSessionId])
  @@index([userId, status, createdAt])
  @@index([score])
  @@index([expiresAt])
  @@map("matches")
}

model PlaceRecommendation {
  id      String @id @default(cuid())
  userId  String @map("user_id")
  placeId String @map("place_id")

  score         Float
  quizSessionId String @map("quiz_session_id")
  distance      Float
  breakdown     Json

  reason    String?
  isViewed  Boolean @default(false) @map("is_viewed")
  isVisited Boolean @default(false) @map("is_visited")

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  place Place @relation(fields: [placeId], references: [id], onDelete: Cascade)

  @@unique([userId, placeId, quizSessionId])
  @@index([userId, createdAt])
  @@index([score])
  @@map("place_recommendations")
}

model EventRecommendation {
  id      String @id @default(cuid())
  userId  String @map("user_id")
  eventId String @map("event_id")

  score         Float
  quizSessionId String @map("quiz_session_id")
  distance      Float
  breakdown     Json

  reason       String?
  isViewed     Boolean @default(false) @map("is_viewed")
  isInterested Boolean @default(false) @map("is_interested")

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId, quizSessionId])
  @@index([userId, createdAt])
  @@index([score])
  @@map("event_recommendations")
}

model DailyQuiz {
  id          String   @id @default(cuid())
  userId      String
  createdAt   DateTime @default(now())
  isCompleted Boolean  @default(false)

  answers QuizAnswer[]
  user    User         @relation("UserDailyQuizzes", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, isCompleted])
  @@map("daily_quizzes")
}

model QuizQuestion {
  id          String       @id @default(cuid())
  title       String
  description String?
  type        QuestionType
  createdAt   DateTime     @default(now())

  options QuizOption[]

  answers QuizAnswer[] @relation("QuestionAnswers")
}

model QuizAnswer {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  dailyQuizId String   @map("daily_quiz_id")
  questionId  String   @map("question_id")
  selectedIds String[] @map("selected_ids")
  answeredAt  DateTime @default(now()) @map("answered_at")

  dailyQuiz DailyQuiz    @relation(fields: [dailyQuizId], references: [id], onDelete: Cascade)
  question  QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade, name: "QuestionAnswers")

  @@index([userId])
  @@index([dailyQuizId])
  @@map("quiz_answers")
}

model QuizOption {
  id         String @id @default(cuid())
  questionId String
  label      String
  icon       String

  question QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

enum QuestionType {
  single
  multiple
}

enum QuizCategory {
  personality
  interest
  lifestyle
  values
  activity
  mood
  social_preference
  general
}

enum MoodSource {
  manual
  quiz
  ai_detected
}

enum MatchStatus {
  pending
  accepted
  declined
  expired
  mutual
}

enum PlaceType {
  bar
  cafe
  restaurant
  gym
  club
  park
  coworking
  museum
  cinema
  beach
  mall
  library
  bookstore
  art_gallery
  studio
}

// ðŸ†• NEW: Hangout place types (untuk user preferences)
enum HangoutPlaceType {
  cafe
  restaurant
  bar
  club
  gym
  park
  mall
  coworking
  library
  bookstore
  beach
  museum
  art_gallery
  cinema
  sports_venue
  community_center
  other
}

enum EventType {
  party
  workshop
  meetup
  concert
  sport
  exhibition
  conference
  networking
  casual_hangout
  fitness_class
  food_tasting
  game_night
}

enum VibeType {
  energetic
  chill
  relaxed
  intense
  social
  intimate
  crowded
  quiet
  active
  passive
  creative
  competitive
  casual
  formal
  romantic
  adventurous
  intellectual
  fun
  trendy
  cozy
  outdoor
  indoor
  calm
  introspective
}

enum InterestCategory {
  sports
  arts
  music
  food
  tech
  gaming
  fitness
  reading
  travel
  wellness
  social
  learning
  entertainment
  general
}

enum EventAttendanceStatus {
  interested
  going
  maybe
  went
}

// ðŸ†• NEW: Visit frequency
enum VisitFrequency {
  daily
  weekly
  monthly
  occasionally
  rarely
}

enum JoinReason {
  MAKE_FRIENDS            @map("make_friends")
  FIND_ACTIVITY_PARTNERS  @map("find_activity_partners")
  EXPLORE_CITY            @map("explore_city")
  TRY_NEW_EXPERIENCES     @map("try_new_experiences")
  PROFESSIONAL_NETWORKING @map("professional_networking")
  DATING_RELATIONSHIPS    @map("dating_relationships")
  NEW_TO_AREA             @map("new_to_area")
  EXPAND_SOCIAL_CIRCLE    @map("expand_social_circle")
  FIND_HOBBY_COMMUNITY    @map("find_hobby_community")
  ATTEND_EVENTS           @map("attend_events")
}
